use std::{
    any::{self, Any},
    panic,
};

use anyhow::anyhow; // this has become one of my favorite error handling libraries
                    //use anyhow::Result;

mod ffi {
    // NOTE: See build.rs on the "EXTERN_LIB_FILENAME" and make sure it matches this
    //       I.e.: "bindings.rs" -> 'target/debug/build/calling_bad_Clibraries-70cc6a23c6099eaa/out/bindings.rs'
    //      /* automatically generated by rust-bindgen 0.69.4 */
    //      extern "C" {
    //          pub fn mid_exit(status: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    //      }
    //      extern "C" {
    //          pub fn mid_access_violation() -> ::std::os::raw::c_int;
    //      }
    //      extern "C" {
    //          pub fn mid_divide_by_zero() -> ::std::os::raw::c_int;
    //      }
    include!(concat!(env!("OUT_DIR"), "/bindings.rs")); // see build.rs `EXTERN_LIB_FILENAME`
}

fn main() {
    //single_thread_apartment();
    multiple_threads_apartment();
}

fn single_thread_apartment() {
    // Output (same on both Linux and Windows):
    //      do_proc_exit(0): About to call mid_exit() from C library
    //      mid_exit(): Calling exit() now...
    do_proc_exit("single_thread_apartment");

    // Output (Linux):
    //      do_div_by_zero(0): About to call mid_divide_by_zero() from C library
    //      mid_divide_by_zero(): about to divide by zero...
    //      mid_divide_by_zero(): This WILL print - In C/C++ NaN and INF are valid answer...
    //      do_div_by_zero(1): mid_divide_by_zero() from C library called successfully
    // Output (Windows):
    //      do_div_by_zero(0): About to call mid_divide_by_zero() from C library
    //      mid_divide_by_zero(): about to divide by zero...
    //      error: process didn't exit successfully: `rust-demo\target\debug\calling_bad_Clibraries.exe` (exit code: 0xc0000094, STATUS_INTEGER_DIVIDE_BY_ZERO)
    do_div_by_zero("single_thread_apartment");

    // Output (Linux):
    //      do_seg_fault(0): About to call mid_access_violation() from C library
    //      mid_access_violation(): about to write some value to NULL pointer; seg-fault here we come...
    //      Segmentation fault (core dumped)
    // Output (Windows):
    //      do_seg_fault(0): About to call mid_access_violation() from C library
    //      mid_access_violation(): about to write some value to NULL pointer; seg-fault here we come...
    //      error: process didn't exit successfully: `rust-demo\target\debug\calling_bad_Clibraries.exe` (exit code: 0xc0000005, STATUS_ACCESS_VIOLATION)
    //      Segmentation fault
    do_seg_fault("single_thread_apartment");
}

fn multiple_threads_apartment() {
    // Output (Linux):
    //
    // Output (Windows):
    //      fork_and_join_0arg(0): About to fork a thread...
    //          >>>>>>> Calling function at address '0x7ff7b0c359a0'
    //      multiple_threads_apartment - do_proc_exit(0): About to call mid_exit() from C library
    //      mid_exit(): Calling exit() now...
    //      error: process didn't exit successfully: `target\debug\calling_bad_Clibraries.exe` (exit code: 0xfffffd66)
    let fn_proc_exit = || do_proc_exit("multiple_threads_apartment");
    //fork_and_join_0arg(fn_proc_exit);

    // Output (Linux):
    //
    // Output (Windows):
    //      fork_and_join_0arg(0): About to fork a thread...
    //          >>>>>>> Calling function at address '0x7ff75d2d5930'
    //      multiple_threads_apartment - do_div_by_zero(0): About to call mid_divide_by_zero() from C library
    //      mid_divide_by_zero(): about to divide by zero...
    //      error: process didn't exit successfully: `C:\Users\HidekiAI\projects\rust-demo\target\debug\calling_bad_Clibraries.exe` (exit code: 0xc0000094, STATUS_INTEGER_DIVIDE_BY_ZERO)
    let fn_div_by_zero = || do_div_by_zero("multiple_threads_apartment");
    //fork_and_join_0arg(fn_div_by_zero);

    // Output (Linux):
    //
    // Output (Windows):
    //      fork_and_join_0arg(0): About to fork a thread...
    //          >>>>>>> Calling function at address '0x7ff6e1415850'
    //      multiple_threads_apartment - do_seg_fault(0): About to call mid_access_violation() from C library
    //      mid_access_violation(): about to write some value to NULL pointer; seg-fault here we come...
    //      error: process didn't exit successfully: `C:\Users\HidekiAI\projects\rust-demo\target\debug\calling_bad_Clibraries.exe` (exit code: 0xc0000005, STATUS_ACCESS_VIOLATION)
    //      Segmentation fault
    let fn_seg_fault = || do_seg_fault("multiple_threads_apartment");
    fork_and_join_0arg(fn_seg_fault);
}

fn fork_and_join_0arg(
    my_function: fn() -> anyhow::Result<String>, // no need for Sync since we are not sharing data between threads
) -> anyhow::Result<String> {
    println!(
        "fork_and_join_0arg(0): About to fork a thread...\n\t>>>>>>> Calling function at address '{:?}'",
        my_function
    );

    // first, fork off a new thread
    let handle = std::thread::spawn(move || {
        let duration_msec = 1000;
        println!(">>> fork_and_join_0arg(1): Inside the NEW thread...  Will yield for {} mSec to let the main thread print first...", duration_msec);
        std::thread::sleep(std::time::Duration::from_millis(duration_msec)); // yield for few mSec to let the main thread print first

        println!(">>> fork_and_join_0arg(1): Inside the NEW thread...  OK, calling now...");
        let catch_result: Result<_, Box<dyn Any + Send>> = panic::catch_unwind(|| {
            println!(">>>> fork_and_join_0arg(1): Inside the NEW thread...  INSIDE catch_unwind()...  OK, calling now...");
            my_function()
        });
        // Handle the panic result if needed
        match catch_result {
            Ok(_) => {
                println!("Thread completed successfully");
                Ok("Success")
            }
            Err(panic_value) => Err(anyhow!("Thread panicked - {:?}", panic_value)),
        }
    });
    // before we join (to get blocked), we'll print something out while the thread is yielded...
    println!(">> fork_and_join_0arg(2): Inside the main thread (outside the spawned thread)...  Will now block self and wait for thread to join back");

    let result = handle.join();
    println!(">> fork_and_join_0arg(4): we're back!");

    // If the spawned thread panics, the join() call will return an Err containing the panic value:
    match result {
        Ok(Ok(value)) => {
            return Ok(format!("fork_and_join_0arg(1): Success! {:?}", value));
        }
        Ok(Err(e)) => {
            println!("fork_and_join_0arg(2): Error! {:?}", e);
            return Err(e);
        }
        Err(e) => {
            println!("fork_and_join_0arg(3): Error! {:?}", e);
            return Err(anyhow!("Thread panicked"));
        }
    }
}

fn fork_and_join_1arg<F, T>(func: F, arg1: T) -> anyhow::Result<String>
where
    F: Fn(T) -> anyhow::Result<String>,
{
    return func(arg1);
}

fn do_proc_exit(debug_str: &str) -> anyhow::Result<String> {
    println!(
        "{} - do_proc_exit(0): About to call mid_exit() from C library",
        debug_str
    );
    let status = -666;
    unsafe {
        let result = ffi::mid_exit(status);
        if result < 0 {
            return Err(anyhow!("mid_exit() from C library failed"));
        }
    }
    println!(
        "{} - do_proc_exit(1): mid_exit() from C library called successfully",
        debug_str
    );
    Ok("Success!".into())
}

fn do_div_by_zero(debug_str: &str) -> anyhow::Result<String> {
    println!(
        "{} - do_div_by_zero(0): About to call mid_divide_by_zero() from C library",
        debug_str
    );
    unsafe {
        let result = ffi::mid_divide_by_zero();
        if result < 0 {
            return Err(anyhow!("mid_divide_by_zero() from C library failed"));
        }
    }
    println!(
        "{} - do_div_by_zero(1): mid_divide_by_zero() from C library called successfully",
        debug_str
    );
    Ok("Success!".into())
}

fn do_seg_fault(debug_str: &str) -> anyhow::Result<String> {
    // access the C function from the generated bindings
    println!(
        "{} - do_seg_fault(0): About to call mid_access_violation() from C library",
        debug_str
    );
    unsafe {
        let result = ffi::mid_access_violation();
        if result < 0 {
            return Err(anyhow!("mid_access_violation() from C library failed"));
        }
    }
    println!(
        "{} - do_seg_fault(1): mid_access_violation() from C library called successfully",
        debug_str
    );
    Ok("Success!".into())
}
